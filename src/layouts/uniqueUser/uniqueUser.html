<link rel="import" href="/bower_components/polymer/polymer.html">
<link rel="import" href="/bower_components/iron-icons/communication-icons.html">
<link rel="import" href="/bower_components/iron-icon/iron-icon.html">
<link rel="import" href="/components/tl-IncSearch/tl-IncSearch.html">
<link rel="import" href="/components/tl-Calendar/tl-DateRangePicker.html">
<link rel="import" href="/components/tl-Chart/tl-LineChart.html">
<link rel="import" href="/components/tl-Chart/libs/Series/LineSeries.html">
<link rel="import" href="/components/tl-Radios/tl-Radios.html">
<link rel="import" href="/components/tl-Radio/tl-Radio.html">
<link rel="import" href="/service/tl-util/tl-util.html">
<link rel="import" href="/service/tl-Flux/tl-Flux.html">

<dom-module name="tl-sample-layout">
	<link rel="import" type="css" href="./sample.css">

	<template>
		<header class="Frame__header">
			<iron-icon icon="communication:location-on"></iron-icon>
			<tl-i18n id="spot.title"></tl-i18n>
			<tl-IncSearch id="spotSearch" items="[[proberNames]]" on-change="onSpotSearchChange" block style="flex: 1;"></tl-IncSearch>
			<tl-DateRangePicker title="集計対象期間を選択" selected-from="[[rangeFrom]]" selected-to="[[rangeTo]]" on-change="updateTargetRange" id="dateRangePicker" range-to="[[maxRangeTo]]"></tl-DateRangePicker>
			<tl-Radios id="interval" title="集計単位を選択" selected="minute" on-change="onIntervalChanged">
				<tl-Radio name="minute">10分</tl-Radio>
				<tl-Radio name="hour">1時間</tl-Radio>
				<tl-Radio name="day">1日</tl-Radio>
				<tl-Radio name="week">1週間</tl-Radio>
				<tl-Radio name="month">1ヶ月</tl-Radio>
			</tl-Radios>
			<!-- <h2 class="Frame__title">
				<tl-i18n id="uniqueuser.name"></tl-i18n>
			</h2> -->
			<!-- <tl-i18n id="date.range.title"></tl-i18n> -->
		</header>
		<div class="Frame__body">

			<div class="Frame__row">
				<div class="Card">
					<div class="Card-row">
						<tl-LineChart id="chart"></tl-LineChart>
						<span class="loadingMessage" style="position:absolute;top:8px;left:16px;">データ読込中...</span>
					</div>
				</div>
			</div>

			<div class="Frame__row">
				<div class="Card">
					<h3 class="Card-title">
						ランキング
						<span class="loadingMessage">データ読込中...</span>
					</h3>
					<div class="Card-row">
						<table class="Ranking">
							<thead class="Ranking-header">
								<tr>
									<th class="Ranking-day">
										日時
									</th>
									<th class="Ranking-count">
										検出数
									</th>
									<th class="Ranking-graph">
										割合
									</th>
								</tr>
							</thead>
							<template is="dom-repeat" items="[[rankings]]">
								<tr>
									<td class="Ranking-day">[[item.day]]</td>
									<td class="Ranking-count">[[item.count]]</td>
									<td class="Ranking-graph">
										<span class="Ranking-graph-bar" style$="[[item.style]]">[[item.rate]]</span>
									</td>
								</tr>
							</template>
						</table>
					</div>
				</div>
			</div>
		</div>
	</template>

	<script>
		Polymer({
			is: 'tl-uniqueUser-layout',
			properties: {
				probers: {
					type: Array,
					value: function() {
						return [];
					},
					radOnly: true
				},
				proberNames: {
					type: Array,
					computed: 'computeProberNames(probers)'
				},
				maxRangeTo: {
					type: String,
					radOnly: true,
					value: kn.KNCalendarModel.date2str(new Date()),
				},
				rangeFrom: {
					type: String,
					radOnly: true
				},
				selectedToDate: {
					type: Object,
					radOnly: true
				},
				rankings: {
					type: Array,
					value: function() {
						return [];
					},
					radOnly: true
				},
				chartSerieses: {
					type: Object,
					value: function() {
						return new Map();
					},
					radOnly: true
				},
				isActivePage: {
					type: Boolean,
					value: false
				}
			},
			_data: null,
			listeners: {
				'enterpagestart': 'onEnterPageStart',
				'leavepagestart': 'onLeavePageStart'
			},
			ready: function() {
				Flux.addStore('/Store/ProberStore.js', this.updateProberStore.bind(this));
				Flux.addStore('/Store/AnalyticsStore.js', this.updateAnalyticsStore.bind(this));
				window.addEventListener('resize', this.onWindowResize.bind(this));
			},
			updateProberStore: function(state) {
				this.set('probers', Array.from(state.probers.values()));
			},
			updateAnalyticsStore: function(state) {
				this.toggleClass('is-loading', state.isLoading);
				this._data = state.data;
				this.updateChart();
				this.updateRankings();
			},


			//ページ遷移関係


			onEnterPageStart: function() {
				this.requestUpdateProbers();
				this.isActivePage = true;
				this.$.chart.notifyResize();
			},
			onLeavePageStart: function() {
				this.requestUpdateProbers();
				this.isActivePage = false;
			},


			//Prober選択


			onSpotSearchChange: function(ev, detail) {
				var model = detail.model,
					prober = this.probers[detail.index];

				if (model.selected) {
					Flux.dispatchAction('analytics.addProber', prober);
					this.addSeries(prober);

				} else {
					Flux.dispatchAction('analytics.removeProber', prober);
					this.removeSeries(prober);
				}
			},
			computeProberNames: function(probers) {
				return probers.map(function(prober) {
					return prober.place;
				});
			},
			requestUpdateProbers: function() {
				Flux.dispatchAction('prober.getAll');
			},


			//集計期間


			updateTargetRange: function() {
				var MS_IN_DAY = 24 * 60 * 60 * 1000,
					TIMEZONE_OFFSET = (new Date().getTimezoneOffset()) * 60 * 1000,
					from = +this.$.dateRangePicker.selectedFromDate,
					to = +this.$.dateRangePicker.selectedToDate;

				from = parseInt((from - TIMEZONE_OFFSET) / MS_IN_DAY) * MS_IN_DAY + TIMEZONE_OFFSET;
				to = (parseInt((to - TIMEZONE_OFFSET) / MS_IN_DAY) + 1) * MS_IN_DAY + TIMEZONE_OFFSET;

				//@TODO 応急処置
				if (to > Date.now()) {
					// from = Date.now() - (to - from);
					to = Date.now();
				}

				Flux.dispatchAction('analytics.setRange', {
					from: from,
					to: to
				});
			},


			//集計単位


			onIntervalChanged: function() {
				var INTERVAL = {
						0: 10,
						'minute': 10,
						1: 60,
						'hour': 60,
						2: 60 * 24,
						'day': 60 * 24,
						3: 60 * 24 * 7,
						'week': 60 * 24 * 7,
						4: 60 * 24 * 30, //@TODO どーする?
						'month': 60 * 24 * 30 //@TODO どーする?
					},
					interval = INTERVAL[this.$.interval.selected];

				if (!interval) throw new Error('Invalid Interval');
				Flux.dispatchAction('analytics.setInterval', interval);
			},


			//チャート


			addSeries: function(prober) {
				var serieses = this.chartSerieses,
					series = new chlib.LineSeries(),
					chart = this.$.chart;

				if (serieses.has(prober.prober_id)) return;

				series.color = chart.getSeriesColor(serieses.size);
				series.name = prober.place;

				chart.chart.appendSeries(series);
				serieses.set(prober.prober_id, series);
			},
			removeSeries: function(proberId) {
				var serieses = this.chartSerieses,
					series = serieses.get(proberId),
					chart = this.$.chart;

				if (!series) return;

				serieses.delete(proberId);
				chart.chart.removeSeries(series);
			},
			updateChart: function() {
				var serieses = this.chartSerieses,
					data = this._data,
					chart = this.$.chart,
					removeList = [];

				serieses.forEach(function(series, proberId) {
					var seriesData = data.get(proberId);
					if (!seriesData) {
						removeList.push(proberId);
						return;
					}

					series.datum = seriesData;
				});

				//削除
				removeList.forEach(this.removeSeries, this);

				if (this.isActivePage) {
					chart.update();
				}
			},
			onWindowResize: function() {
				if (this.isActivePage) {
					this.$.chart.notifyResize();
				}
			},


			//ランキング


			updateRankings: function() {
				//TODO 暫定的にprobers[0] の情報のみ表示
				if (this.probers.length === 0) {
					this.set('rankings', []);
					return;
				}

				var data = this._data.get(this.probers[0].prober_id);
				if (!data || data.length === 0) {
					this.set('rankings', []);
					return;
				}

				var M = 10,
					sorted, max, rankings;

				sorted = kn.util
					.quickTopSort(data, M, function(a, b) {
						return a[1] > b[1] ? 1 : a[1] < b[1] ? -1 : 0;
					})
					.slice(0, M),

					max = sorted[0][1];

				rankings = sorted.map(function(data) {
					var rate = data[1] * 100 / max,
						d = new Date(data[0]);

					return {
						day: kn.i18n.formatDate('format.date.text.mdwin/:', d),
						count: data[1],
						rate: rate + '%',
						style: 'width:' + rate + '%;'
					};
				});

				this.set('rankings', rankings);
			}
		});

	</script>
</dom-module>
